const sumMergeObj = (...objs) => {
  return objs.reduce((acc, cur) => {
    for (let prop in cur) {
      if (acc[prop]) {
        acc[prop] += cur[prop];
      } else {
        acc[prop] = cur[prop];
      }
    }
    return acc;
  }, {});
};

// Takes in an arbitrary amount of articles as an argument, and returns a POJO
// with the keys being tags, and the values being the number of times that tag
// is associated with the article
export default (...articles) => {
  return articles.reduce((acc, cur) => {
    return sumMergeObj(
      acc,
      cur.userArticles.reduce((userArticleAcc, userArticleCur) => {
        return sumMergeObj(
          userArticleAcc,
          userArticleCur.taggings.reduce((taggingsAcc, taggingsCur) => {
            const name = taggingsCur.tag.name;
            if (taggingsAcc[name]) {
              taggingsAcc[name] += 1;
            } else {
              taggingsAcc[name] = 1;
            }
            return taggingsAcc;
          }, {})
        );
      }, {})
    );
  }, {});
};

// Takes the tag object generated by the above function and returns a sorted
// list of every tag, with the most associated tag appearing first, limited by
// n entries
export const sortTags = (tagListObject, n = tagListObject.length) => {
  let sortedTags = [];

  for (let tag in tagListObject) {
    sortedTags.push([tag, tagListObject[tag]]);
  }
  sortedTags.sort((a, b) => a[1] - b[1]);

  return sortedTags.map((tag) => tag[0]).slice(0, n);
};
