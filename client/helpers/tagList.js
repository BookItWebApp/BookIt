const sumMergeObj = (...objs) => {
  return objs.reduce((acc, cur) => {
    for (let prop in cur) {
      if (acc[prop]) {
        acc[prop] += cur[prop];
      } else {
        acc[prop] = cur[prop];
      }
    }
    return acc;
  }, {});
};

// Takes in an arbitrary amount of articles as an argument, and returns a POJO
// with the keys being tags, and the values being the number of times that tag
// is associated with the article
export default (...articles) => {
  return articles.reduce((acc, cur) => {
    return sumMergeObj(
      acc,
      cur.userArticles.reduce((userArticleAcc, userArticleCur) => {
        return sumMergeObj(
          userArticleAcc,
          userArticleCur.taggings.reduce((taggingsAcc, taggingsCur) => {
            const name = taggingsCur.tag.name;
            if (taggingsAcc[name]) {
              taggingsAcc[name] += 1;
            } else {
              taggingsAcc[name] = 1;
            }
            return taggingsAcc;
          }, {})
        );
      }, {})
    );
  }, {});
};

// Takes the tag object generated by the above function and returns a sorted
// list of every tag, with the most associated tag appearing first
export const sortTags = (tagListObject) => {
  let sortedTags = [];

  const sortedValues = Object.values(tagListObject).sort().reverse();
  for (let i of sortedValues) {
    for (let prop in tagListObject) {
      if (tagListObject[prop] === i) {
        sortedTags.push(prop);
      }
    }
  }
  return sortedTags;
};
